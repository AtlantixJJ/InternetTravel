# 互联网出行设计报告

2015011313 徐鉴劲 计54

## 项目架构

### 本地

1. `main` 用于本地测试寻路的正确性。

2. `create_index` 用于预先生成索引文件。

### 前端

使用了高德地图的JS API。

功能点主要有：

1. 选择起点，选择终点，进行拼车查询，重新开始一次查询。

2. 显示起点、终点，备选出租车。

3. 如果找不到出租车，就会弹出一个窗口，提示用户重新开始。

4. 点击出租车，会显示路线，路线上会显示别的乘客。 

### 后端

使用python django完成，主要功能是：

1. 初始化寻路API。

2. 处理第一类请求：点击地图上的点，返回一个距离它最近的点。

3. 处理第二类请求：给定起点和终点，找出备选出租车和它的路径。

这三个功能通过一个python API进行封装`server/netbase/api.py`。

这个API完成的功能是：

1. 初始化计算后端`pyengine`，然后将两类请求发送给`pyengine`进行计算。

2. 需要将参数转化为dictionary进行传递。

### pyengine

封装了C++的计算后端，实现方法是调用C++ 的动态链接库，主要代码在`pyengine/__init__.py`中。同时，`src/extern.h`和`src/extern.cpp`完成了C++库接口的定义。

python调用C++动态链接库的方法是`ctypes`包，难点是参数的传递。通过ctypes进行强制类型定义，然后在C++中使用`PyObject`这个类就可以完成参数传递了。

C++中使用`PyObject`需要包含`Python.h`文件。使用`PyList_New`,`PyList_Append`和`Py_BuildValue`就可以在C++中操作python的list对象了。使用list作为传递参数的方法是最合适的，但是要注意的一点是，如果对象没有被返回，需要使用`Py_DECREF`进行内存的释放，否则会出现异常。

### C++寻路库

#### InternetTravel

`src/InternetTravel.h`中定义的`InternetTravel`完成了寻路算法的功能。

它的功能是初始化`GPTree`外部模块，然后对于每一次给出的起点和终点，返回一个结果列表：

```c
SolutionList query(const Node* src, const Node* dst);
```

这个函数会遍历所有出租车，将符合条件的（绕路距离<=10）出租车都存起来，然后按照绕路距离进行排序，选取前5个，然后构建路径，返回结果。

#### Vehicle

上面一步中，符合条件的出租车在这个类中进行计算，同时返回一个接送乘客的顺序。

流程是：

1. 根据地表距离过滤明显不符合的备选项。

2. 计算六点距离矩阵（车位置，新乘客起点，新乘客终点，车上乘客0~3人的终点），得到他们两两之间的距离。距离的计算则是调用`Map`中的 `roadmap_distance` 函数.

3. 枚举这六个点的位置（也有可能小于6个点，比如车上乘客不足3人），按照全排列的方式进行尝试，选择一个距离最小的。函数是`getMinDist`，调用函数需要指出出发节点，然后得到的就是一个TSP问题的结果。

枚举的时候需要注意到一个特殊情况：新乘客的起点和终点出现顺序必须是一前一后的。

4. 将ID列表转化成Node列表，返回结果。

#### Map

完成的功能是

1. 初始化地图（从磁盘中读取节点、边、索引文件）。前两个初始化到本类中，最后一个调用GPTree的接口`tree_setup`进行初始化。

2. 计算路网距离。调用接口`tree_search`。

3. 恢复路网路径。调用接口`tree_find_path`。

#### Node

结点中提供了距离计算函数

#### Solution

主要是作为结果的存储，增加了一个用于比较偏序大小的函数：按照总绕路距离进行排序，如果相同就按照当前乘客的绕路距离进行排序。

总绕路距离是当前乘客绕路距离加上车上乘客绕路距离(d5-d1+d3-d4)。

### 核心寻路算法设计

#### 寻路算法设计

绕路距离的重新定义（增加了d5）：

各个距离的含义如下：

|距离|含义|
|:--|:--|
|d1|car送目前乘客到达的距离|
|d2|car到达新乘客的距离|
|d3|car接起了新乘客后送达所有人的距离|
|d4|新乘客位置到目的地距离|
|d5|car从接起新乘客到送完所有乘客的全程距离|
|d6|car接起了新乘客后送达当前乘客的距离|

原始的绕路距离对于车上乘客的绕路距离是这样定义的：

$d_{pass} = d_2 + d_3 - d_1$。

这样是不准确的，因为它限定了这辆车必须先到达新乘客的所在位置，然后再进行送达。但是实际上可以先送达某些乘客，然后再接起新的乘客。

所以我对于车上乘客绕路距离的定义为：

$d_{pass} = d_5 - d_1$。

这是一个全程距离，包含了上面所说的情况。

但是实际上这个绕路距离也是不准确的，车上的每一个乘客计算绕路距离是总距离减去他们各自的最短距离：

$d_{pi} = d_5 - d_{4i}$, $d_{pass} = \sum d_{pi} = nd_5 - \sum d_{4i}$。

不过这样定义没有必要，需要一个相对绕路距离。即：在没有接送新乘客之前，他们有一个到达顺序$\pi_1$，然后接送新乘客后有一个到达顺序$\pi_2$。对于一个到达循序$\pi$，可以计算出每一个乘客的绕路距离：

$d_{pi}(\pi) = dist(src_i, dst_{\pi(i)})$。

但是这样定义，就需要知道每一个乘客的上车地点，这是信息中不存在的。

所以我还是采用了第一种改进。

对于新乘客的绕路距离也是不准确的，因为他不一定是最后一个下车的。

所以应该是：在最终的路线中，新乘客上车和下车之间的距离是真正的距离（d6），新乘客的绕路距离应该是

$d_{new} = d_6 - d_4$。


#### 对GPTree算法的封装和修改

直接使用两点路线修改的G Plus Tree，在他的原文件中增加一些接口函数，然后编译成动态链接库。

但是后来发现原来的输入输出使用标准输入输出，效率太低，速度太慢还与python的解释器冲突了，所以我对其进行了修改，使用二进制文件进行输入输出，大大提升了效率。

同时，用于时间计算的times数组经常导致崩溃，删掉以后恢复正常。除此以外，一些不必要的调试信息也被删除了。

### 效果展示

